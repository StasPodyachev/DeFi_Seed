// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity ^0.8.9;

import "./AddressResolver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title Gives inherited contracts the ability to work with AddressResolver and improves the
 * security of working with addresses. Reduces the chance of missing the necessary addresses in the
 * contracts.
 */

abstract contract MixinResolver is Ownable {
    AddressResolver public resolver;

    /// @dev Holds a mapping of caches to the addresses.
    mapping(bytes32 => address) private addressCache;

    constructor(address _resolver) {
        resolver = AddressResolver(_resolver);
    }

    /// @return combination of the two arrays: `first` and `seond`
    function combineArrays(
        bytes32[] memory first,
        bytes32[] memory second
    ) internal pure returns (bytes32[] memory combination) {
        combination = new bytes32[](first.length + second.length);

        for (uint256 i = 0; i < first.length; i++) {
            combination[i] = first[i];
        }

        for (uint256 j = 0; j < second.length; j++) {
            combination[first.length + j] = second[j];
        }
    }

    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses
    function resolverAddressesRequired()
        public
        pure
        virtual
        returns (bytes32[] memory addresses)
    {}

    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses
    function resolverAddresses()
        public
        pure
        virtual
        returns (bytes32[] memory addresses)
    {}

    function _resolveAddressesFinish() internal virtual {}

    /**
     * @notice Checking for the necessary addresses
     * Emits a `CacheUpdated` event
     */
    function rebuildCache() public {
        bytes32[] memory requiredAddresses = resolverAddressesRequired();
        // The resolver must call this function whenver it updates its state
        for (uint256 i = 0; i < requiredAddresses.length; i++) {
            bytes32 name = requiredAddresses[i];
            // Note: can only be invoked once the resolver has all the targets needed added
            address destination = resolver.requireAndGetAddress(
                name,
                string(abi.encodePacked("Resolver missing target: ", name))
            );
            addressCache[name] = destination;
            emit CacheUpdated(name, destination);
        }

        bytes32[] memory addresses = resolverAddresses();
        // The resolver must call this function whenver it updates its state
        for (uint256 i = 0; i < addresses.length; i++) {
            bytes32 name = addresses[i];
            // Note: can only be invoked once the resolver has all the targets needed added
            address destination = resolver.getAddress(name);
            addressCache[name] = destination;
            emit CacheUpdated(name, destination);
        }

        _resolveAddressesFinish();
    }

    /**
     * @notice Checking if the call to the rebuildCache() method will succeed.
     * @dev This may be important as rebuildCache() may result in a revert
     */
    function isResolverCached() external view returns (bool) {
        bytes32[] memory requiredAddresses = resolverAddressesRequired();
        for (uint256 i = 0; i < requiredAddresses.length; i++) {
            bytes32 name = requiredAddresses[i];
            // false if our cache is invalid or if the resolver doesn't have the required address
            if (
                resolver.getAddress(name) != addressCache[name] ||
                addressCache[name] == address(0)
            ) {
                return false;
            }
        }

        return true;
    }

    /**
     * @dev Getting an address that must exist in the address cache
     */
    function requireAndGetAddress(
        bytes32 name
    ) internal view returns (address) {
        address _foundAddress = addressCache[name];
        require(
            _foundAddress != address(0),
            string(abi.encodePacked("Missing address: ", name))
        );
        return _foundAddress;
    }

    function getAddress(bytes32 name) internal view returns (address) {
        return addressCache[name];
    }

    event CacheUpdated(bytes32 name, address destination);

    // LINE_SALT_PROD_{1695991730}
}
