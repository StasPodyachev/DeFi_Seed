// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "./../interfaces/IAddressResolver.sol";
import "./MixinResolver.sol";

/**
 * @title This contract stores addresses that inherited contracts of the MixinResolver can use
 */
contract AddressResolver is Ownable, IAddressResolver {
    /// @dev Holds a mapping of hashes of contract names to the addresses.
    mapping(bytes32 => address) public repository;

    /**
     * @notice Adding contract addresses
     * @param names Array of the bytes of contract names
     * @param destinations Array of the contract addresses
     * @dev In the `names` array, need to be passed the bytes received as a result of calling
     * keccak256 for the name of the contact. For example keccak256(bytes("D4X")).
     */
    function importAddresses(
        bytes32[] calldata names,
        address[] calldata destinations
    ) external onlyOwner {
        if (names.length != destinations.length) revert LengthError();

        for (uint256 i = 0; i < names.length; i++) {
            bytes32 name = names[i];
            address destination = destinations[i];
            repository[name] = destination;
            // emit AddressImported(name, destination);
        }
    }

    /**
     * @dev Must be called for those contracts for which the addresses they use have been updated
     * @param destinations Addresses of contracts for which addresses have been updated
     */
    function rebuildCaches(
        MixinResolver[] calldata destinations
    ) external onlyOwner {
        for (uint256 i = 0; i < destinations.length; i++) {
            destinations[i].rebuildCache();
        }
    }

    /**
     * @notice Checking if the contract address was previously imported
     * @param names Array of the bytes of contract names
     * @param destinations Array of the contract addresses
     * @return boolean that indicate are addresses imported
     * @dev In the `names` array, need to be passed the bytes received as a result of calling
     * keccak256 for the name of the contact. For example keccak256(bytes("D4X")).
     */
    function areAddressesImported(
        bytes32[] calldata names,
        address[] calldata destinations
    ) external view returns (bool) {
        for (uint256 i = 0; i < names.length; i++) {
            if (repository[names[i]] != destinations[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * @notice Get contract address by name
     * @param name Contract name in bytes
     * @return address Address of the contract or address(0) if the contract was not imported
     * @dev `name` need to be passed in the bytes received as a result of calling keccak256 for
     * the name of the contact. For example keccak256(bytes("D4X")).
     */
    function getAddress(bytes32 name) external view returns (address) {
        return repository[name];
    }

    /**
     * @notice Get the address of the contract, which must be imported before.
     * @param name Contract name in bytes
     * @param reason Error message in case of missing contract
     * @return address of the contract
     * @dev `name` need to be passed in the bytes received as a result of calling keccak256 for
     * the name of the contact. For example keccak256(bytes("D4X")).
     */
    function requireAndGetAddress(
        bytes32 name,
        string calldata reason
    ) external view returns (address) {
        address _foundAddress = repository[name];
        require(_foundAddress != address(0), reason);
        return _foundAddress;
    }

    event AddressImported(bytes32 name, address destination);

    // LINE_SALT_PROD_{1695991730}
}
